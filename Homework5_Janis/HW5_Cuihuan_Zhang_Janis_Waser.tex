\documentclass[12pt]{extarticle}
\usepackage{tikz}
\usepackage{amsmath,amssymb}
\usepackage {graphicx}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{watermark}
\usepackage{varwidth}
\usepackage{arydshln}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
%\usepackage{scrlayer-scrpage}
\usepackage{forest}
\usepackage{fancyhdr}
\pagecolor{white}
 \geometry{bottom= 30mm}
\usepackage{enumitem}


 
 
\title{Data Management Assignment 5}
\author{Cuihuan Zhang \& Janis Waser} 
\fancyhead[L]{Data Management}
\fancyhead[C]{Homework 5}
\fancyhead[R]{Cuihuan Zhang \& Janis Waser}
\renewcommand\headrulewidth{0pt}
\pagestyle{fancy}
\pagenumbering{arabic}

\begin{document}

\maketitle \vspace{-10mm}
\rule{\linewidth}{0.4pt}


\begin{flushleft}
\begin{enumerate}[label=\textbf{\Alph*.}]

\item 
\begin{enumerate}[label=\arabic*)]
\item \begin{enumerate}[label=(\alph*)]
\item If we are inserting at the beginning of a heap it takes only 1 operation. 
\item If we have no pointer to the back, it takes N operations to get there and insert the value.
\end{enumerate}
\item It takes log N operations to find the position where the value has to be inserted if the sequence is balanced (no overflow values). Unless the inserted value belonged to the end for example if a new maximum was inserted in which case the moving would not be necessary, every value which position is after in the sequence (tail) has to be moved taking N operations.  Added up this gives us log N + N operations. 
\item In a 2-3 tree it always takes O(log N) operations to insert a value. Either the inserted value can be positioned at the lowest level for which one has to go down the tree to find the place, and since the tree is guaranteed to be balanced it takes exactly log N steps.

The other case is where there is no place at the lowest level and therefore value have to propagate up, but again it takes log N operations in the worst case to go up the entire tree this gives us log N + log N steps which in the big-O notation is also O(log N).
\end{enumerate}
\item \begin{enumerate}[label=\arabic*)] 
\item If for every key there exists a pointer to the file where the key is stored, we call it a dense index, sparse otherwise. So it is a dense index if every key is indexed. 
\item If every key that is in between two indexed keys is stored in the same file then we call it a clustered file, if this is not the case then it is unclustered. 
\end{enumerate}
\item
\item The first option is to read R once and compare with S which needs to be done 1000 times (2000/2), this gives read R + read 500/4 S= 2000/2 + 1000*4000/4=1'001'000.

The other option is where you read S first and compare 1000 (4000/4) times with R  this gives read S+ read 1000 R= 4000/4+ 1000*2000/2=1'001'000. The second option is considerably worse hence we opt to read R and compare with S.
\end{enumerate}
\end{flushleft}
\end {document}